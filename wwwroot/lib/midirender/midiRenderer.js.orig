<<<<<<< HEAD
// midiRenderer.js


/**
 * drawScore
 * ----------
 * Renders a musical score from a MIDI file and displays it in the specified HTML element.
 *
 * @param {File} file - The MIDI file to render.
 * @param {string} ELEMENT_FOR_RENDERING - The ID of the HTML element where the score SVG will be rendered.
 * @param {string} ELEMENT_FOR_COMMENTS - The ID of the HTML element where status or error messages will be displayed.
 * @param {number} [GENERALWIDTH=1200] - The width of the rendered score in pixels.
 * @param {number} [HEIGHT=200] - The height of each stave row in pixels.
 * @param {number} [TOPPADDING=20] - The top padding for the score in pixels.
 * @param {number} [BARWIDTH=250] - The width of each measure/bar in pixels.
 * @param {number} [CLEFZONE=60] - The width reserved for the clef and time signature zone in pixels.
 * @param {number} [Xmargin=10] - The left margin for the score in pixels.
 *
 * Reads the provided MIDI file, parses its contents, and renders the musical notation using VexFlow.
 * Stores the resulting SVG and comments in sessionStorage for later retrieval.
 * Displays success or error messages in the comments element.
 */

function drawScore(file, ELEMENT_FOR_RENDERING, ELEMENT_FOR_COMMENTS, GENERALWIDTH = 1200, HEIGHT = 170, TOPPADDING = 20, BARWIDTH = 250, CLEFZONE = 60, Xmargin = 10) {
    console.log("refresh score is running");
=======
// виведення нот
function refreshScore(file, ELEMENT_FOR_RENDERING, ELEMENT_FOR_COMMENTS, GENERALWIDTH = 1200, HEIGHT = 170, BARWIDTH = 250, TOPPADDING = 10, CLEFZONE = 60, Xmargin = 10) {
    console.log(`refresh score is running, file:`,   `
        GENERALWIDTH: ${GENERALWIDTH}, HEIGHT: ${HEIGHT}, BARWIDTH: ${BARWIDTH}`);
>>>>>>> mastererror
    const notationDiv = document.getElementById(ELEMENT_FOR_RENDERING);
    const commentsDiv = document.getElementById(ELEMENT_FOR_COMMENTS);


    if (file) {
        console.log("File selected:", file);
        const reader = new FileReader();
        notationDiv.innerHTML = "";
        commentsDiv.innerHTML = "";
        reader.onload = function (e) {
            console.log("File read successfully");
            const uint8 = new Uint8Array(e.target.result);

<<<<<<< HEAD
            var GENERALHEIGHT = 170;

            try {
                renderMidiFileToNotation(uint8, ELEMENT_FOR_RENDERING, GENERALWIDTH, HEIGHT, TOPPADDING, BARWIDTH, CLEFZONE, Xmargin); // ноти , GENERALWIDTH, HEIGHT, TOPPADDING, BARWIDTH, CLEFZONE, Xmargin
=======
            const midiFile = new MIDIFile(arrayBuffer);
            const midiEvents = midiFile.getMidiEvents();
            const ticksPerBeat = midiFile.header.getTicksPerBeat();

            // Перевірка наявності EndTrack
            ensureEndEvent(midiEvents);

            //обчислення кількості тактів
            measuresLength = getMeasureCount(midiEvents, ticksPerBeat)
            measuresPerStave = GENERALWIDTH / BARWIDTH
            console.log(`length: ${measuresLength} measures`)

            //обчислення висоти
            const GENERALHEIGHT = calculateRequiredHeight(
                measuresLength,
                GENERALWIDTH,
                BARWIDTH,
                HEIGHT,
                TOPPADDING,
                CLEFZONE,
                Xmargin
            );

            try {
                renderMidiFileToNotation(midiFile, midiEvents, ticksPerBeat, ELEMENT_FOR_RENDERING, GENERALWIDTH, GENERALHEIGHT, HEIGHT, TOPPADDING, BARWIDTH); // ноти , GENERALWIDTH, HEIGHT, TOPPADDING, BARWIDTH, CLEFZONE, Xmargin
>>>>>>> mastererror
                const svg = notationDiv.querySelector("svg");
                if (svg) {
                    sessionStorage.setItem("notationSVG", svg.outerHTML);
                }
                commentsDiv.innerHTML = `File rendered successfully`;
                sessionStorage.setItem("comment", commentsDiv.innerHTML)
            }
            catch (error) {
                console.error("Error rendering MIDI file:", error);
                commentsDiv.innerHTML = `Error rendering MIDI file ${error}`;
                sessionStorage.setItem("comment", commentsDiv.innerHTML);
            }
        };
        reader.readAsArrayBuffer(file);
    }
}

<<<<<<< HEAD
function renderMidiFileToNotation(uint8, ELEMENT_FOR_RENDERING, GENERALWIDTH, HEIGHT = 170, TOPPADDING = 20, BARWIDTH = 250, CLEFZONE = 60, Xmargin = 10) {
=======

///РЕНДЕР НОТ
function renderMidiFileToNotation(midiFile, midiEvents, ticksPerBeat, ELEMENT_FOR_RENDERING, GENERALWIDTH, GENERALHEIGHT, HEIGHT = 170, TOPPADDING = 20, BARWIDTH = 250, CLEFZONE = 60, Xmargin = 10) {
>>>>>>> mastererror
    if (!ELEMENT_FOR_RENDERING) {
        throw new Error(`Element with id ${ELEMENT_FOR_RENDERING} not found.`);
    }

<<<<<<< HEAD
    // Парсимо MIDI-файл
    let midiData = MidiParser.Uint8(uint8);

    // ticksPerBeat
    let ticksPerBeat = Array.isArray(midiData.timeDivision) ? 480 : midiData.timeDivision; // 480 - дефолт

    // Збираємо всі події з усіх треків
    let midiEvents = [];
    midiData.track.forEach(track => {
        if (Array.isArray(track.event)) {
            midiEvents = midiEvents.concat(track.event);
=======
    console.log("START RENDERING MIDI events");

    const factory = new Vex.Flow.Factory({
        renderer: {
            elementId: ELEMENT_FOR_RENDERING,
            width: GENERALWIDTH,
            height: GENERALHEIGHT
>>>>>>> mastererror
        }
    });


<<<<<<< HEAD
    // Додаємо поле absTime для кожної події (накопичення deltaTime)
    let absTime = 0;
    midiEvents.forEach(event => {
        absTime += event.deltaTime || 0;
        event.absTime = absTime;
        console.log(`absTime for ev. ${event.type} added: ${absTime}`)
    });

=======

    const { numerator, denominator, ticksPerMeasure } = getTimeSignatureAndTicksPerMeasure(midiFile);
>>>>>>> mastererror

    // Розбивка на такти
    const measures = splitEventsIntoMeasures(midiEvents, ticksPerBeat);
    GENERALHEIGHT = calculateRequiredHeight(measures.length, GENERALWIDTH, BARWIDTH, HEIGHT, TOPPADDING, CLEFZONE, Xmargin);

    setTimeout(() => {
        const factory = new Vex.Flow.Factory({
            renderer: {
                elementId: ELEMENT_FOR_RENDERING,
                width: GENERALWIDTH,
                height: GENERALHEIGHT
            }
        });

        const context = factory.getContext();
        const score = factory.EasyScore();

        renderMeasures(measures, ticksPerBeat, score, context, Xmargin, TOPPADDING, BARWIDTH, CLEFZONE, HEIGHT, GENERALWIDTH);
    }, 0);
}

<<<<<<< HEAD
function renderMeasures(measures, ticksPerBeat, score, context, Xmargin, TOPPADDING, BARWIDTH, CLEFZONE, HEIGHT, GENERALWIDTH) {
    let Xposition = Xmargin;
    let Yposition = TOPPADDING;
    let thresholdGap = ticksPerBeat / 8;

    // Початковий розмір такту (за замовчуванням 4/4)
    let currentNumerator = 4;
    let currentDenominator = 4;


=======
function renderMeasures(measures, ticksPerBeat, ticksPerMeasure, score, context, Xmargin, numerator, denominator, TOPPADDING, BARWIDTH, CLEFZONE, HEIGHT, GENERALWIDTH) {

    let thresholdGap = ticksPerBeat / 8;
    let activeNotes = {};
    let lastNotesByPitch = {};
>>>>>>> mastererror

    measures.forEach((measure, index) => {
        ({ currentNumerator, currentDenominator } = adjustTimeSignature(measure, currentNumerator, currentDenominator));
        let ticksPerMeasure = currentNumerator * ticksPerBeat * 4 / currentDenominator;

        const barStartAbsTime = index * ticksPerMeasure;
<<<<<<< HEAD

        if (Xposition > GENERALWIDTH - BARWIDTH) {
            Yposition += HEIGHT; Xposition = Xmargin;
            console.log("Yposition updated:", Yposition);
        } else {
            console.log(`General width ${GENERALWIDTH} vs ${BARWIDTH} + ${Xposition}`);
        }
        console.log(`Processing measure ${index + 1} starting from tick: ${barStartAbsTime} X=${Xposition}  Y=${Yposition}`);

        let STAVE_WIDTH = BARWIDTH;
        if (index === 0) {
            STAVE_WIDTH += CLEFZONE;
            console.log("First stave width:", STAVE_WIDTH);
        }
=======
        let { Xposition, Yposition } = getXYposition(Xmargin, TOPPADDING, GENERALWIDTH, BARWIDTH, HEIGHT, index, barStartAbsTime);
        let STAVE_WIDTH = getStaveWidth(BARWIDTH, index, CLEFZONE);
>>>>>>> mastererror

        // Намалювали нотний стан
        const stave = new Vex.Flow.Stave(Xposition, Yposition, STAVE_WIDTH);
        if (index === 0) {
            stave.addClef("treble").addTimeSignature(`${currentNumerator}/${currentDenominator}`);
        }

        stave.setContext(context).draw();

        const notes = [];
        const ties = [];
<<<<<<< HEAD
        const activeNotes = {};
        let lastNoteOffTime = 0;
        let lastNoteOnTime = -1;

        measure.forEach((event, idx) => {
=======
        let lastNoteOffTime = 0; // Відстежуємо час останньої події NoteOff
        let lastNoteOnTime = -1;

        //Додаємо ноти з попереднього такту якщо є
        AddNotesFromPreviousBar(activeNotes, measure);


        // Обробка подій для кожного такту
        measureWithAbsTime.forEach((event, index) => {


            //якщо подія NoteOn
            if (event.subtype === MIDIEvents.EVENT_MIDI_NOTE_ON) {
>>>>>>> mastererror

            console.log("MIDI Event:", event);

            if (event.type === 0x9 && !(event.data && event.data[1] === 0)) {

                AddStartRest(idx, event, ticksPerBeat, thresholdGap, notes);

                addRestsBetween(lastNoteOffTime, event, ticksPerBeat, thresholdGap, notes);

                if (event.absTime == lastNoteOnTime) {
                    console.log(`NoteOn coincides with previous NoteOn: ${event.absTime}`);
                }
                activeNotes[event.data[0]] = event.absTime; // event.data[0] — номер ноти
                lastNoteOnTime = event.absTime;
<<<<<<< HEAD
            } else if (event.type === 0x8 || (event.type === 0x9 && event.data && event.data[1] === 0)) { // Note Off
                const startTime = activeNotes[event.data[0]];
=======
            }
                // якщо NoteOff
            else if (event.subtype === MIDIEvents.EVENT_MIDI_NOTE_OFF) {
                const startTime = activeNotes[event.param1];
>>>>>>> mastererror
                if (startTime !== undefined) {
                    const durationTicks = event.absTime - startTime;
                    const pitch = event.data[0];
                    if (durationTicks > 0) {
                        const durationsCode = getDurationFromTicks(durationTicks, ticksPerBeat);
                        const { key, accidental } = midiNoteToVexFlow(pitch);

<<<<<<< HEAD
                        let previousNote = null;
                        durationsCode.forEach((durationCode) => {
                            const note = processNoteElement(durationCode, key, accidental);
                            notes.push(note);
                            if (previousNote) {
                                ties.push(new Vex.Flow.StaveTie({
                                    first_note: previousNote,
                                    last_note: note
                                }));
                            }
                            previousNote = note;
                        });
                        delete activeNotes[event.data[0]];
                    }
                    else {
                        console.warn("durationTicks <= 0", { event, startTime });
                    }
                }
                else {
                    console.warn("undefined starttime!")
=======
                    let previousNote = null;

                    durationsCode.forEach((durationCode) => {
                        const note = processNoteElement(durationCode, key, accidental);
                        notes.push(note);

                        // Додаємо Tie для перенесених нот (тільки якщо це перша нота для pitch у цьому такті)
    if (event.absTime === 0 && lastNotesByPitch[pitch]) {
        AddTie(lastNotesByPitch[pitch], ties, note);
        // Після першої ліги для цього pitch у такті більше не додаємо
        lastNotesByPitch[pitch] = null;
    }

                        // Якщо є попередня нота, додаємо лігу
                        AddTie(previousNote, ties, note);

                        previousNote = note;
                    });

                    if (activeNotes[event.param1])

                    delete activeNotes[event.param1];
>>>>>>> mastererror
                }
                lastNoteOffTime = event.absTime;

            }

            if (activeNotes) {
                // Домалювати всі ноти, які залишилися активними до кінця такту
                Object.keys(activeNotes).forEach(pitch => {
                    const startTime = activeNotes[pitch];
                    const durationTicks = ticksPerMeasure - startTime;
                    if (durationTicks > 0) {
                        const durationsCode = getDurationFromTicks(durationTicks, ticksPerBeat);
                        const { key, accidental } = midiNoteToVexFlow(Number(pitch));
                        let previousNote = null;
                        durationsCode.forEach(durationCode => {
                            const note = processNoteElement(durationCode, key, accidental);
                            notes.push(note);
                            AddTie(previousNote, ties, note);
                            previousNote = note;
                        });
                    }
                });


            }

        });

        // Додаємо паузи, якщо такт незаповнений
        lastNoteOffTime = addMissingRests(lastNoteOffTime, notes, ticksPerMeasure, thresholdGap, ticksPerBeat);

        notes.forEach((note) => {
            console.log(`Note: ${note.keys}, duration: ${note.duration}`);
        });

<<<<<<< HEAD
=======

        // Оновити lastNotesByPitch для всіх pitch, які були у цьому такті
        notes.forEach(note => {
            // Визначаємо pitch для ноти (наприклад, з note.keys[0])
            // Якщо note.keys[0] == "c/4", pitch = midiNoteFromVexKey(note.keys[0])
            // Реалізуйте цю функцію відповідно до вашої логіки
            const pitch = midiNoteFromVexKey(note.keys[0]);
            lastNotesByPitch[pitch] = note;
        });

        //Малюємо тут

>>>>>>> mastererror
        try {
            if (notes.length > 0) {
                const voice = score.voice(notes);
                voice.setStrict(false);
                const formatter = new Vex.Flow.Formatter();
                formatter.joinVoices([voice]).format([voice], BARWIDTH - 50);
                voice.draw(context, stave);
                ties.forEach((tie) => tie.setContext(context).draw());
            } else {
                console.warn(`Measure ${index + 1} has no notes to render.`);
            }
        } catch (error) {
            console.error(`Error rendering measure ${index + 1}: ${error.message}<br>`);
        }
        Xposition += STAVE_WIDTH;
    });

    // Оновлена функція для додавання пауз з урахуванням ticksPerMeasure
    function addMissingRests(lastNoteOffTime, notes, ticksPerMeasure, thresholdGap, ticksPerBeat) {
        while (lastNoteOffTime < ticksPerMeasure - thresholdGap) {
            const remainingTicks = ticksPerMeasure - lastNoteOffTime;
            console.log(`add Missing Rest is running: remaining: ${remainingTicks}`);
            const restDurations = getDurationFromTicks(remainingTicks, ticksPerBeat);
            let timeadded = 0;
            restDurations.forEach((restDuration) => {
                notes.push(createRest(restDuration));
                timeadded += calculateTicksFromDuration(restDuration, ticksPerBeat);
            });
            lastNoteOffTime += timeadded;
            console.log(`adding a rest done, time added = ${timeadded}, update lastNoteOffTime: ${lastNoteOffTime}`);
        }
        return lastNoteOffTime;
    }
}

<<<<<<< HEAD
function adjustTimeSignature(measure, currentNumerator, currentDenominator) {
    for (const event of measure) {
        if (event.type === 0xFF && event.metaType === 0x58 && Array.isArray(event.data)) {
            currentNumerator = event.data[0];
            currentDenominator = Math.pow(2, event.data[1]);
            break;
        }
    }
    return { currentNumerator, currentDenominator };
}

=======
>>>>>>> mastererror
function AddNotesFromPreviousBar(activeNotes, measure) {
    Object.keys(activeNotes).forEach(pitch => {
        measure.unshift({
            subtype: MIDIEvents.EVENT_MIDI_NOTE_ON,
            param1: Number(pitch),
            absTime: 0
        });
        console.log(`add note ${pitch} from previous measure`);
    });
}

<<<<<<< HEAD
/**
 * getTimeSignature
 * ----------------
 * Визначає розмір такту (чисельник і знаменник) для нотного стану на основі подій першого такту.
 *
 * @param {Array} measures - Масив тактів, де кожен такт — це масив MIDI-подій.
 * @returns {Object} Об'єкт з полями numerator (чисельник) і denominator (знаменник) розміру такту.
 *
 * Логіка:
 * - Перебирає події першого такту (measures[0]).
 * - Якщо знаходить meta-подію типу 0x58 (Time Signature), повертає відповідний розмір такту.
 * - Якщо не знайдено, повертає стандартний розмір 4/4.
 */
function getTimeSignature(measures) {
    let numerator = 4, denominator = 4;
    if (measures.length > 0 && measures[0].length > 0) {
        for (const event of measures[0]) {
            if (event.type === 0xFF && event.metaType === 0x58 && Array.isArray(event.data)) {
                numerator = event.data[0];
                denominator = Math.pow(2, event.data[1]);
                break;
            }
        }
    }
    return { numerator, denominator };
=======
function AddTie(previousNote, ties, note) {
    if (previousNote) {
        ties.push(new Vex.Flow.StaveTie({
            first_note: previousNote,
            last_note: note
        }));
    }
}

function getXYposition(Xmargin, TOPPADDING, GENERALWIDTH, BARWIDTH, HEIGHT, index, barStartAbsTime) {
    let Xposition = Xmargin;
    let Yposition = TOPPADDING;
    if (Xposition > GENERALWIDTH - BARWIDTH) {
        Yposition += HEIGHT; Xposition = Xmargin;
        console.log("Yposition updated:", Yposition);
    }
    else {
        console.log(`General ${GENERALWIDTH} - ${BARWIDTH} vs ${Xposition}`);
    }
    console.log(`Processing measure ${index + 1} starting from tick: ${barStartAbsTime} X=${Xposition}  Y=${Yposition}`);
    return { Xposition, Yposition };
}

function getStaveWidth(BARWIDTH, index, CLEFZONE) {
    let STAVE_WIDTH = BARWIDTH;
    if (index === 0) {
        STAVE_WIDTH += CLEFZONE;
        console.log("First stave width:", STAVE_WIDTH);
    }
    return STAVE_WIDTH;
>>>>>>> mastererror
}

function addRestsBetween(lastNoteOffTime, event, ticksPerBeat, thresholdGap, notes) {
    if (lastNoteOffTime > 0 && event.absTime > lastNoteOffTime) {
        const gapTicks = event.absTime - lastNoteOffTime;
        const restDurations = getDurationFromTicks(gapTicks, ticksPerBeat);
        if (gapTicks > thresholdGap) {
            restDurations.forEach((restDuration) => {
                console.log(`current event abs time ${event.absTime} vs lastNoteOffTime: ${lastNoteOffTime}: rest is needed: ${restDuration}`);
                notes.push(createRest(restDuration));
            });
        }
    }
}

function AddStartRest(index, event, ticksPerBeat, thresholdGap, notes) {
    if (index === 0) {
        console.log(`first event in measure event abs time ${event.absTime}`);
        if (event.absTime > 0) {
            const restDurations = getDurationFromTicks(event.absTime, ticksPerBeat);
            if (event.absTime > thresholdGap) {
                restDurations.forEach((restDuration) => {
                    notes.push(createRest(restDuration));
                    console.log(`adding rest: ${restDuration}`);
                });
            }
        }
        else { console.log("no rest needed"); }
    }
}

function processNoteElement(durationCode, key, accidental) {
        console.log(`Processing note with durationCode: ${durationCode}, key: ${key}, accidental: ${accidental}`);

    key = key.replace('/', ''); // випиляти зайве /
    const note = createNote(key, durationCode);

    // Додаємо знак альтерації, якщо він є
    if (note && accidental) {
        note.addAccidental(0, new Vex.Flow.Accidental(accidental));
    }

    return note;
}


function calculateRequiredHeight(measuresCount, GENERALWIDTH, BARWIDTH, HEIGHT, TOPPADDING = 20, CLEFZONE = 60, Xmargin = 10) {
    let Xposition = Xmargin;
    let Yposition = TOPPADDING;
    let rows = 1;
    for (let i = 0; i < measuresCount; i++) {
        let STAVE_WIDTH = BARWIDTH;
        if (i === 0) STAVE_WIDTH += CLEFZONE;
        if (Xposition > GENERALWIDTH - BARWIDTH) {
            rows++;
            Xposition = Xmargin;
        }
        Xposition += STAVE_WIDTH;
    }
    return TOPPADDING + HEIGHT * rows;
}
<<<<<<< HEAD

function prepareMidiEvents(arrayBuffer) {
    console.log("Preparing MIDI events from arrayBuffer...");
    let midiEvents = [];
    // Перетворюємо ArrayBuffer на Uint8Array для MidiParser
    let uint8 = (arrayBuffer instanceof Uint8Array) ? arrayBuffer : new Uint8Array(arrayBuffer);
    if (typeof MIDIParser !== 'undefined') {
        MIDIParser.parse(uint8, function(obj) {
            if (obj && obj.track && Array.isArray(obj.track.events)) {
                midiEvents = midiEvents.concat(obj.track.events);
            }
        });
    } else if (typeof MidiParser !== 'undefined') {
        MidiParser.parse(uint8, function(obj) {
            if (obj && obj.track && Array.isArray(obj.track.events)) {
                midiEvents = midiEvents.concat(obj.track.events);
            }
        });
    } else {
        console.error('Neither MIDIParser nor MidiParser is defined.');
    }
    return midiEvents;
}
=======
>>>>>>> mastererror
